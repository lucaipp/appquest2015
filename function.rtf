{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf130
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red170\green13\blue145;\red92\green38\blue153;\red0\green116\blue0;
\red38\green71\blue75;\red46\green13\blue110;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab529
\pard\tx529\pardeftab529\pardirnatural\partightenfactor0

\f0\fs22 \cf0 \CocoaLigature0     \cf2 func\cf0  colorizeSquaresOnPath(path: [\cf3 CGPoint\cf0 ], color: \cf3 UIColor\cf0 ) \{\
\cf4 //        var previousPoint:CGPoint?\
\cf0         \cf2 for\cf0  currentPoint \cf2 in\cf0  path \{\
            \cf5 colorizeSquares\cf0 (color) \{ square \cf2 in\cf0 \
                \cf2 return\cf0  \cf6 CGRectContainsPoint\cf0 (square.\cf3 frame\cf0 , currentPoint)\
            \}\
\cf4 //            if let lineStart = previousPoint \{\
//                colorizeSquares(color) \{ square in\
//                    return LineIntersection.rectContainsLine(square.frame, lineStart: lineStart, lineEnd: currentPoint) // TODO: return whether the square's frame has been intersected by the drawn path segment. Use the LineIntersection class. -> DONE\
//                \}\
//            \} else \{\
//                /* For the first point we only check if the point is contained in a view's coordinates rect */\
//                colorizeSquares(color) \{ square in\
//                    return CGRectContainsPoint(square.frame, currentPoint)\
//                \}\
//            \}\
//            previousPoint = currentPoint\
\cf0         \}\
    \}}